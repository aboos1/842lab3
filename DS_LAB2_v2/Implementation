processRules:
	check rules against message
	if is send message:
		put message in out_buffer
	if is received message:
		put message in the received_message_array;
		
Send(message):
	if message is a group msg
		add original source to DestArray
		sendMulticast(message, false)
	else:
		send it
		
sendMulticast(message, flag):
	For all dest (not self):
		create a copy of message with host/port
		put message in multicastSendQueue
	
	increment system timestamp

receiveMulticast(message):
	Apply rules for message:
	if drop or delay:
		put in delayedInBuffer
		return
	if normal or duplicate:
		put in an array
	
		Check all message in array:		
		If ACK:
			Process(ACK)
		else:
			if not src
				check hold_back_queue
				if not in
					add to hold_back_queue
					create a new ACK:(
							group = original group
							kind = ACK
							data = KEY(original_src, seqNum)
							src = local
							dest = dest
							originalSrc = src;
							seqNum = seqNum	//??????????????
							start, length, timestamp, clockService
							)
							
					updateACKMap
					send_multicast (ACK)
					[start timer]
	
	????? whether update system timestamp when receive a group message?
	return holdBackQueue
	
Process(ACK)
	update ACK_Map
	check whether OK to deliver
		if yes
			if (src)
				clear ack_map
				stop timer
				clear send_queue
			else
				send to deliver_queue
				clear map
				stop timer
		else
			not deliver
		 